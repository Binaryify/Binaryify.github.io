<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>杨凡</title>
    <link>https://nekocode.cn/</link>
    <description>Recent content on 杨凡</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 16 Dec 2018 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://nekocode.cn/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Kotlin 101</title>
      <link>https://nekocode.cn/posts/kotlin_101/</link>
      <pubDate>Sun, 16 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://nekocode.cn/posts/kotlin_101/</guid>
      <description>

&lt;h2 id=&#34;kotlin-简介&#34;&gt;Kotlin 简介&lt;/h2&gt;

&lt;p&gt;2011 年，作为全球最先进 IDE 开发商之一的 JetBrains 揭露了一项正处于开发中的编程语言 —— Kotlin。它是一门跑在 JVM 上，和 Java 间具有高互操作性的全新语言。JetBrains 通过多年来和各种编程语言打交道的经验，为 Kotlin 整合了多项现代编程语言特性。&lt;/p&gt;

&lt;p&gt;2017 年，Google 在 I/O 大会上宣布将 Kotlin 作为 Android 开发的官方支持语言。彼时，Kotlin 的开发者社区开始了爆炸性的增长，而 Netflix、Pinterest、Trello、Kickstarter 等知名公司也早已开始使用 Kotlin。&lt;/p&gt;

&lt;p&gt;2018 年，目前 Kotlin 1.3 正式版本已经发布，更多的语言特性得到了支持。而随着官方提供了更多的编译后端，也让 Kotlin 摆脱了 JVM 的束缚，使用 Kotlin 编写的代码可以编译成机器码甚至 JavaScript 而跑在不同的运行环境中。另外，根据 Google 官方的调查，目前已有 40% 的 Android 开发者选择使用 Kotlin 进行编程工作，国内抖音、网易有道词典、大众点评、知乎等大量应用也开始引入 Kotlin。&lt;/p&gt;

&lt;h2 id=&#34;使用-kotlin-有什么好处&#34;&gt;使用 Kotlin 有什么好处？&lt;/h2&gt;

&lt;p&gt;既然 Google 已经宣布 Kotlin 成为 Android 开发的官方支持语言，也说明了至少在 Android 开发上使用 Kotlin 目前已经毫无障碍了。那么作为 Android 开发者，对比 Java 而言，使用 Kotlin 语言能获得什么好处呢？&lt;/p&gt;

&lt;p&gt;第一点，使用 Kotlin 能够让我们的代码变得更简洁。我们都知道 Java 以它语法的严谨性而著名，它支撑起了世界上各种大型、复杂的计算机软件。然而 ，它的语法是有历史包袱而且略显啰嗦的，对比更灵活的现代语言，使用 Java 来实现同样的逻辑通常需要写更多的代码。而没有历史包袱的 Kotlin 则吸取了现代语言各种灵活简洁的语法，让开发者在 JVM 上也能写出简洁的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// Java
final ArrayList&amp;lt;String&amp;gt; a = new ArrayList&amp;lt;&amp;gt;();
// Kotlin
val a = ArrayList&amp;lt;String&amp;gt;()

// Java
public String b(String c) {
    return &amp;quot;Test: &amp;quot; + c.substring(2);
}
// Kotlin
fun b(c: String) = &amp;quot;Test: ${c.substring(2)}&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了语法上的各种简便，Kotlin 的标准库也提供了很多实用的方法来精简你的代码，例如针对开发中最常用的「集合」，Kotlin 提供了封装让你可以轻松创建集合类、使用和 Java Stream 相似但更丰富的接口来操作集合：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// 创建包含元素 1、3、5、7 的 ArrayList
arrayListOf(1, 3, 5, 7)
        // 过滤出集合中大于 3 的元素
        .filter { it &amp;gt; 3 }
        // 转换成字符串
        .map { &amp;quot;$it, &amp;quot; }
        // 循环输出
        .forEach { println(it) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多 Kotlin 比 Java 语法更精简的例子可以查看 &lt;a href=&#34;https://fabiomsr.github.io/from-java-to-kotlin/index.html&#34;&gt;From Java to Kotlin&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;第二点，使用 Kotlin 能让你的程序更安全。Java 工程师最常见陷阱之一就是访问了空的引用而导致空指针异常，而 Java 在语法上无法描述某个引用是否可空，所以开发者要背负起更多的心智负担而不得不经常进行判空操作。虽然目前可以通过 Annotation + IDE 提示的方式来一定程度上减轻这个负担，但这并不是一个强约束，在 IDE 上的提示是可被忽略的。&lt;/p&gt;

&lt;p&gt;而 Kotlin 在语法上对此进行了强约束。在 Kotlin 中定义某个引用时必须描述其是否为可空类型，对于可空类型引用的不安全访问会在编译期报错：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// 不可空类型，可以直接访问
val a: String = &amp;quot;&amp;quot;
a.substring(2)

// 可空类型
val b: String? = null
b.substring(2) // 不安全访问，编译报错
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这有利于在运行前察觉并处理可能的空指针异常。而且 Kotlin 还提供了 &lt;code&gt;?.&lt;/code&gt;、&lt;code&gt;?:&lt;/code&gt;、类型自动转换等便捷的语法来辅助处理可空类型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val b: String? = null
b?.substring(2) // 当 b 不为空时才调用 substring()
if (b is String) {
    b.substring(2) // 自动把 b 转换成不可空类型
}
val c = b ?: &amp;quot;&amp;quot; // 如果 b 为空的话，则返回 ?: 操作符右边的值
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上两点是 Kotlin 能给大多数 Java 开发者带来的直接好处。但 Kotlin 能给开发者带来的也不仅仅只有这些，它有着完美的 IDE 支持（这也正是 JetBrains 的强处），它与 Java 之间的高互操作性让你可以轻松使用 Java 生态中丰富的库，而它对各种现代语言新特性（例如协程、函数式编程）的支持，能让你在面对不同的计算机问题时有更多不同的思考和解决方式。&lt;/p&gt;

&lt;h2 id=&#34;必须知道的一些缺点&#34;&gt;必须知道的一些缺点&lt;/h2&gt;

&lt;p&gt;我们要知道，任何编程语言在设计时都需要做各种取舍。Kotlin 在提供高灵活性的背后也需要开发者付出一定的代价：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;语法糖过多，加重开发者心智负担；&lt;/li&gt;
&lt;li&gt;部分语法糖，例如 Extensions，会破坏代码的可阅读性；&lt;/li&gt;
&lt;li&gt;灵活性过高，不同的开发者容易产生不同的表达偏好；&lt;/li&gt;
&lt;li&gt;过度依赖 IDE，脱离 IDE 可能让代码难以阅读和维护。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实际上这也是大多数语法灵活、语法糖多的语言的共同问题。但我们不必过于担心，通过使用强大的 IDE 和建立代码规范这些问题都能被解决。作为开发者，我们应该把精力放在用更少的代码、更快、更方便地描述出我们想要的「逻辑」上，其他的负担都交给编译器或 IDE 吧，这也正是高阶编程语言诞生的初衷。&lt;/p&gt;

&lt;h2 id=&#34;作为-android-开发者是否应该学习-kotlin&#34;&gt;作为 Android 开发者是否应该学习 Kotlin？&lt;/h2&gt;

&lt;p&gt;总所周知，由于 Google 和 Oracle 之间的各种政治斗争，导致 Android 开发者一直以来只能用上阉割版的 Java。大部分开发者甚至是最近几年才开始用上、甚至开始知道 Lambda 表达式，而像 Stream 之类的工具更是无人知晓。虽然期间有传闻过要支持 Go 和 Dart 语言，但很快也都音讯全无了。&lt;/p&gt;

&lt;p&gt;而 Kotlin 的出现正好弥补了 Android 开发生态中一块巨大的短板 —— 落后的开发语言。而且，Kotlin 和 Java 十分相似（甚至很多人把它认为是 Java 的增强版），所以从 Java 过渡到 Kotlin 的门槛比起其他语言来说相对更低。而基于 JVM 又让 Kotlin 的代码可以很轻松地运行在 Android 平台上。这么看来，Kotlin 确实比起 Google 自己的 Go 和 Dart 来说更适合作为 Android 平台的开发语言，也难怪 Google 最终敲定 Kotlin。&lt;/p&gt;

&lt;p&gt;纵观未来，随着 Google 和 JetBrains 深度的合作，Kotlin 也肯定会成为 Android 开发生态中最先进的工具之一。目前通过 Kotlin Android Extensions 已经可以很方便地在 Activity 中直接通过 Id 名来直接访问对应的 View：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;import kotlinx.android.synthetic.main.activity_main.*

// 设置 id 为 helloTextView 的 TextView 的文本
helloTextView.text = &amp;quot;Hello World!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而 Google 官方推出的 &lt;a href=&#34;https://developer.android.com/kotlin/ktx&#34;&gt;KTX 库&lt;/a&gt; 更是让开发者能够更方便地使用 Kotlin 来开发 Android 应用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// 使用 KTX 前
view.viewTreeObserver.addOnPreDrawListener(
    object : ViewTreeObserver.OnPreDrawListener {
        override fun onPreDraw(): Boolean {
            viewTreeObserver.removeOnPreDrawListener(this)
            actionToBeTriggered()
            return true
        }
    }
)

// 使用 KTX 后
view.doOnPreDraw {
     actionToBeTriggered()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外一个好消息是，今年 11 月刚发布的 Gradle 5.0 也宣布支持了 Kotlin DSL，这意味着我们甚至可以用 Kotlin 来写我们的构建脚本了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;android {
    compileSdkVersion(27)
    defaultConfig {
        applicationId = &amp;quot;com.test.app&amp;quot;
        minSdkVersion(15)
        targetSdkVersion(27)
        versionCode = 1
        versionName = &amp;quot;1.0&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以从各种迹象来看，答案其实已经很明显了。Kotlin 的诞生以及被 Google 的钦点，对一直以来被语言限制生产力的 Android 开发者们而言意义非凡。而就 Google 和 JetBrains 的影响力来看，未来几年 Kotlin Android 开发者的数量将呈爆炸式增长，市场对于 Kotlin 工程师的需求也将会不断增加。所以，学习 Kotlin 不但能让你接触到更先进的工具、思想，也肯定能让你在人才市场上更具竞争力。&lt;/p&gt;

&lt;p&gt;事实上，根据 Github 今年发表的 &lt;a href=&#34;https://octoverse.github.com/projects#languages&#34;&gt;Octoverse 报告&lt;/a&gt; ，Kotlin 已经成为增长速度最快的语言。&lt;/p&gt;

&lt;h2 id=&#34;先尝试一下吧&#34;&gt;先尝试一下吧&lt;/h2&gt;

&lt;p&gt;如果你已经对 Kotlin 产生兴趣，可以先通过官方的 &lt;a href=&#34;https://play.kotlinlang.org/&#34;&gt;Playground&lt;/a&gt; 来在线尝试下 Kotlin 的语法。它还包括一些列用于演示各种语法的实例，以及一个完整的语法课程。&lt;/p&gt;

&lt;p&gt;如果你想在本地创建一个全新的使用 Kotlin 编写的 Android 应用项目，参照官方文档中的 &lt;a href=&#34;https://kotlinlang.org/docs/tutorials/kotlin-android.html&#34;&gt;Getting started with Android and Kotlin&lt;/a&gt; 来进行即可，目前 Android Studio 已经完全支持 Kotlin 语言。&lt;/p&gt;

&lt;p&gt;而如果你想在一个使用 Java 的 Android 应用项目中同时使用 Kotlin，也是完全没问题的。通过上一个链接的教程引入 Kotlin Gradle Plugin，即可在你的源码目录下通过 Android Studio 菜单直接创建 Kt 源码文件。&lt;/p&gt;

&lt;p&gt;有人可能会担心使用过程中遇到各种坑 。实际上，笔者在 2015 年就开始使用 Kotlin 了，期间在语法、IDE 支持、Kotlin 注解处理器上都遇到官方不少的坑，但由于官方的迭代速度足够快，很多问题很快就被修复了。另外，Kotlin 的社区也十分活跃，如果遇到坑或者问题也基本都能在上面找到回答。&lt;/p&gt;

&lt;p&gt;而自从 16 年 Kotlin 1.0 发布之后的版本就更加稳定了，工具链、IDE 支持也都十分完善。所以大可不必担心会遇到无法解决的坑。&lt;/p&gt;

&lt;h2 id=&#34;最后说点什么&#34;&gt;最后说点什么&lt;/h2&gt;

&lt;p&gt;有科学家表明，使用不同的自然语言会影响人的思考方式。而编程，亦是如此。激进的 Kotlin 和保守的 Java 之间的差异，肯定会给我们带来不一样的思考问题的方式。而这些不一样，也肯定会影响未来 Android 开发的新风向。&lt;/p&gt;

&lt;p&gt;在笔者看来，Android 开发界随着 Kotlin 的出现实际上已经到了一个新的纪元，浪潮已来，为了不被浪潮所击退，请用力拥抱 Kotlin 吧！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>被滥用的 GUI 设计模式</title>
      <link>https://nekocode.cn/posts/abused_gui_design_pattern/</link>
      <pubDate>Sun, 02 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://nekocode.cn/posts/abused_gui_design_pattern/</guid>
      <description>&lt;p&gt;随便侃些个人对 GUI 设计模式的看法。&lt;/p&gt;

&lt;p&gt;近些年来，随着 Fronted 技术的火热和推进，古老的（至少有几十年历史）用来解决 GUI 应用中代码组织问题的「GUI 设计模式」现在也成为了 Frontend 工程师的热门话题，MVC、MVP、MVVM 等设计模式在网路上被议论不绝。有很多工程师开始通过写博文来介绍它们、阐述自己对它们的理解，甚至在 Github 上开源了各种 GUI 设计模式的实现。&lt;/p&gt;

&lt;p&gt;顺着这种趋势，很多 Frontend 工程师甚至把 GUI 设计模式当成一种「规范」乃至「教条」。然而糟糕的现实是，大多数人并没有正确地、细致地理解和运用 GUI 设计模式，反而因为 Tradeoff 导致它的缺点被放大。结果就是你用了大量精力、模板代码去设计它，反而让它更复杂、更难维护了。&lt;/p&gt;

&lt;p&gt;例如，当你打开 Github 上大多数试图实现 GUI 模式的仓库时会发现，整个应用大概也就两三个页面、四五个网络接口，就可能已经创建了几十个类和接口来承载那单薄的逻辑了。举个更具体的例子，我个人曾经接触过几个用 MVP 模式设计的大型 Android 工程，在进行维护或者迭代的时候，各种带有问题的设计反而让 MVP 模式成为了累赘。&lt;/p&gt;

&lt;p&gt;首先，工程中大多数 View 都是粒度大耦合度高的 Activity 类，而且很多 View 里为了方便，会提供 &lt;code&gt;fun updateView(user: UserModel)&lt;/code&gt; 这样的方法，导致 View 和领域/业务模型直接耦合了。再者，View 和 Model 中还会包含了跳转页面、发送全局消息等各种带有「副作用」的命令，这也让面向接口编程成为了形式主义。&lt;/p&gt;

&lt;p&gt;所以与其「舍本逐末」、「知其然而不知其所以然」，倒还不如理解问题的本质。于 GUI 设计模式而言，实际上最重要的思想是「分而治之」，通过把之前都写在一处的代码按照职能分到不同的类，来让它们实现「低耦合高内聚」。所以，我们更应该把 GUI 设计模式当成一思想而不是具体的手段，更也没必要用各种所谓的模板来解决问题，只要你能把热点、关键代码设计得足够低耦合高内聚，那么你完全可以无视所有 GUI 设计模式。&lt;/p&gt;

&lt;p&gt;例如上面提到的 &lt;code&gt;fun updateView(user: UserModel)&lt;/code&gt; 问题，实际有两种方式来让 View 和业务模型 UserModel 解耦：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// 方法一
interface ViewA {
    fun updateText1(text: String)
    fun updateText2(text: String)
    // ...
}
class PresenterA {
    fun onSomeEvent() {
        val userModel = Apis.requestUser()
        viewA.updateText1(userModel.name)
        viewA.updateText2(userModel.age.toString())
    }
}

// 方法二
interface ViewA {
    data class ViewAttributes(
        text1: String,
        text2: String,
        // ...
    )
    fun updateView(view: ViewAttributes)
}
class PresenterA {
    fun onSomeEvent() {
        val viewAttributes = Apis.requestUser().mapTo ViewAttributes()
        viewA.updateView(viewAttributes)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;方法一更倾向于用「指令」来描述 View，方法二则更倾向于用「数据」。而我个人更喜欢方法二，因为数据是运行时可处理、可持久化的，甚至可以跨进程、跨语言、乃至跨机器共享的。讲个题外话，Web Fronted 里 Redux 等状态管理工具捧起了一个很火的词「时间旅行」。在我看来核心思想其实也是把指令下沉，用数据（/状态）来描述上层逻辑，这样就可以在运行时实现逻辑可记录、可回放。&lt;/p&gt;

&lt;p&gt;这里还有一点需要注意的，&lt;code&gt;ViewAttributes&lt;/code&gt; 必须是 View 的领域模型，字段名称应当仅和 View 本身相关，而不应该和其他领域有关系。&lt;/p&gt;

&lt;p&gt;再回到之前提到过的另外一个问题：View 和 Model 里的副作用。这个其实更容易解决，只需要把所有副作用移到外部（/调用方）就好了。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// 有副作用
class ViewA {
    fun onTitleClick() {
        sendBroadcast(&amp;quot;x&amp;quot;)
    }
}

// 无副作用
class ViewA {
    fun onTitleClick() {
        caller.onTitleClick()
    }
}
class PresenterA {
    fun onTitleClick() {
        sendBroadcast(&amp;quot;x&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上，只懂得 OOP（面向对象编程）的工程师很容易造成前面提到的问题，因为他们习惯了依赖「外部状态」来解决问题（类的实例本身也是一个状态），但是在状态数量不断增加的情况下，状态的管理反而会成为一个新的大难题。而 OOP 提倡类的「低耦合高内聚」实际上可以看成是在解决状态管理的问题。&lt;/p&gt;

&lt;p&gt;所以在文章的最后，我强烈推荐工程师们可以学习下 FP（函数式编程）。相对于 OOP 而言，FP 的思想则是摒弃外部状态，它实现的是粒度更小的函数级别的「低耦合高内聚」，你只需要保证你的函数是无副作用的然后管理好函数内部的状态就可以了。而维持这种编程思想，能让你轻松驾驭巨型、复杂的项目，甚至能让你的代码更容易被调试，更容易被并行执行。&lt;/p&gt;

&lt;p&gt;对于 Android 工程师们来说，Kotlin 目前的火热正是让大家有了更了解 FP 的机会。之后我也会写些和 Kotlin、FP 有关的文章。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://nekocode.cn/about/</link>
      <pubDate>Sun, 11 Nov 2018 01:15:00 +0800</pubDate>
      
      <guid>https://nekocode.cn/about/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/nekocode&#34;&gt;&lt;img src=&#34;https://avatars0.githubusercontent.com/u/4783781?s=460&amp;v=4&#34; style=&#34;max-width:15%;min-width:40px;float:right;&#34; alt=&#34;Github repo&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一个致力于使用计算机科学为社会解决难题的男人，喜欢一切美的事物（例如贯彻禅道的 Python 语言），也喜欢一切有创造力的工具和技术。如果猫能成为这个宇宙的通用货币之一，我愿意把我 50% 的财产换成猫。&lt;/p&gt;

&lt;p&gt;在看我的博客之前，本着严肃的态度在此声明，本人不保证所有发表言论的正确性，如有错误的地方，欢迎到 &lt;a href=&#34;https://github.com/nekocode/nekocode.cn/issues&#34;&gt;{这里}&lt;/a&gt; 提交你的看法。本博客所有文章欢迎转载，但请遵守 &lt;a href=&#34;https://creativecommons.org/licenses/by-nc-sa/3.0/&#34;&gt;{CC 协议}&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;你可以通过这些链接来更了解我：&lt;a href=&#34;https://github.com/nekocode&#34;&gt;我的 Github&lt;i class=&#34;icon-github-circled&#34;&gt;&lt;/i&gt;&lt;/a&gt;, &lt;a href=&#34;https://gist.github.com/nekocode&#34;&gt;我的 Gists&lt;i class=&#34;icon-github-circled&#34;&gt;&lt;/i&gt;&lt;/a&gt;, &lt;a href=&#34;https://nekocode.cn/project-gallery/&#34;&gt;我的项目画廊&lt;/a&gt;, &lt;a href=&#34;https://nekocode.cn/resume.pdf&#34;&gt;我的简历&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GraphQL 纪要（二）</title>
      <link>https://nekocode.cn/posts/graphql_summary_2/</link>
      <pubDate>Sat, 20 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://nekocode.cn/posts/graphql_summary_2/</guid>
      <description>

&lt;h2 id=&#34;resolver-设计&#34;&gt;Resolver 设计&lt;/h2&gt;

&lt;p&gt;我们可能会在 Resolver 里做一些耗时的操作（例如操作 Database）。为了保证我们尽可能快地响应用户的查询，我们必须保证只对那些用户需要的字段进行查询。&lt;/p&gt;

&lt;p&gt;首先举个反例，我们定义了以下的 Schema：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Query {
  getPost: Post
}

type Post {
  title: String
  authorName: String
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应的 Resolver Map：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export const resolverMap: IResolvers = {
  Query: {
    getPost: {
      resolve: () =&amp;gt; {
        const post = queryPostDbTable();
        const author = queryUserDbTable(post.authorId);
        return {
          title: post.title,
          authorName: author.name;,
        };
      },
    },
  },
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，在 getPost 字段的 Resolver 里会查询 Post 和 User 表。糟糕的是，即便用户并没有查询 authorName 字段，在获取 getPost 字段的时候也会查询 User 表。这造成了冗余的数据库操作。&lt;/p&gt;

&lt;p&gt;为了解决这个问题，我们应当把 authorName 字段的获取放到另一个 Resolver 里。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export const resolverMap: IResolvers = {
  Query: {
    getPost: {
      resolve: () =&amp;gt; {
        return queryPostDbTable();
      },
    },
  },
  Post: {
    authorName: {
      resolve: (post) =&amp;gt; {
        return queryUserDbTable(post.authorId).name;
      },
    },
  },
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样可以只在用户查询到 authorName 字段时才去查询 User 表。&lt;/p&gt;

&lt;p&gt;现在再假设一下，如果 Post 里还要返回用户头像路径的话，例如 Schema 为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Post {
  title: String
  authorName: String
  authorAvatar: String
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种情况，Resolver 又不好设计了。&lt;/p&gt;

&lt;p&gt;实际上，查询一次 User 表就可以同时获得 authorName 和 authorAvatar 字段了。但如果按照上面的设计，把这两个字段放在单独的 Resolver 里的话，那么如果用户同时查询这两个字段，会查询两次 User 表。&lt;/p&gt;

&lt;p&gt;所以说这种扁平的 Schema 设计其实是不好，更好的设计应该是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Post {
  title: String
  author: User
}

type User {
  name: String
  avatar: String
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应 Resolver Map：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export const resolverMap: IResolvers = {
  Query: {
    getPost: {
      resolve: () =&amp;gt; {
        return queryPostDbTable();
      },
    },
  },
  Post: {
    author: {
      resolve: (post) =&amp;gt; {
        return queryUserDbTable(post.authorId);
      },
    },
  },
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;graphql-orver-prisma&#34;&gt;GraphQL Orver Prisma&lt;/h2&gt;

&lt;p&gt;Prisma 是基于 GraphQL 的最流行的 ORM 框架之一。我们可以使用 Prisma 提供的类似 GraphQL Schema 的语法来定义我们的所有 Model，然后 Prisma 会帮我们在数据库中建立对应的表和列，并生成一个包含增删查改这些 Model 功能的 GraphQL 服务。&lt;/p&gt;

&lt;p&gt;简单来说，通过 Prisma，我们可以使用 GraphQL 语句来操作数据库。&lt;/p&gt;

&lt;p&gt;而使用 Prisma 的好处是，我们可以 Prisma 上再搭建一层 GraphQL 服务来处理更高层的业务逻辑，这样很多操作 Model 的 GraphQL 请求可以直接转发给 Prisma 处理。在定义 Schema 时，很多 Type 甚至可以复用 Prisma 生成的。&lt;/p&gt;

&lt;p&gt;有兴趣的可以看下我写的 &lt;a href=&#34;https://github.com/nekocode/typescript-graphql-over-prisma&#34;&gt;DEMO&lt;/a&gt;。它能帮助你快速搭建一个后端服务。&lt;/p&gt;

&lt;h2 id=&#34;其它&#34;&gt;其它&lt;/h2&gt;

&lt;p&gt;实际上，无论在功能还是性能上，GraphQL 都是特别薄的一层，它所做的仅仅是把 GraphQL 语句解析成 AST，然后执行对应的 Resolver 而已。你甚至可以把它作为 Api Gateway，用它来包裹其它微服务的接口。&lt;/p&gt;

&lt;p&gt;而对比过往 Rest 的接口设计，GraphQL 作为一门「语言」描述明显能力更强。你可以在一条 GraphQL 语句里按需查询你所有需要的数据，仅需要一次网络请求，而如果你的 Resolver 设计的足够好的话，不会像 Rest 接口那样可能造成冗余的查询。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GraphQL 纪要</title>
      <link>https://nekocode.cn/posts/graphql_summary/</link>
      <pubDate>Fri, 19 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://nekocode.cn/posts/graphql_summary/</guid>
      <description>

&lt;h2 id=&#34;schema-graphql-语句&#34;&gt;Schema &amp;amp; GraphQL 语句&lt;/h2&gt;

&lt;p&gt;GraphQL 是一门查询语言，使用它可以描述你需要哪些数据。而 Schema 则是用于声明你能够查询什么样的数据。&lt;/p&gt;

&lt;p&gt;举个例子，下面的是 Schema：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Query {
  hello: String
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过以上 Schema 的声明，你可以写下这么一条 GraphQL 查询语句：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;query {
  hello
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;schema&#34;&gt;Schema&lt;/h2&gt;

&lt;p&gt;Schema 里主要有两个核心的概念，类型（Type）和字段（Field）。举个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type User {
  name: String
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面定义了一个名为 User 的类型，并且这个类型里包含了一个叫做 name 的字段。
注意，字段必须声明类型，可以声明为 Int、String 这类基础类型，也可以声明为自定义的类型。另外，字段是可以包含参数的，这让它看起来有点像函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type User {
  name: String
  posts(count: Int): [Post]
}

type Post {
  title: String
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如这里 User 类型里的 posts 字段，它接受一个名为 count 的参数并返回一个 Post 类型的列表。&lt;/p&gt;

&lt;h2 id=&#34;schema-里的-query-和-mutation-类型&#34;&gt;Schema 里的 Query 和 Mutation 类型&lt;/h2&gt;

&lt;p&gt;在 Schema 里面有两个约定的类型：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Query {
}

type Mutation {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们假设，任何 GraphQL 语句都其实是在查询 Document 对象的子字段，而 Document 里面有且只有以下两个直接子字段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Document {
  query: Query
  mutation: Mutation
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;想要在 GraphQL 语句中查询其它字段，只能把要查询的字段放到 Query 和 Mutation 类型里面。例如我们想添加一个用来查询用户信息的字段，那我们可以在 Query 类型里添加一个 me 字段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Query {
  me: User
}

type User {
  name: String
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么用户就可以用下面的 GraphQL 语句来查询自己的名称了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;query {
  me {
    name
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是，这里的 query 是字段名，返回的是一个 Query 类型。me 是 Query 类型里的字段，而 name 是 User 类型里的字段。&lt;/p&gt;

&lt;h2 id=&#34;query-mutation-的字段约定&#34;&gt;Query &amp;amp; Mutation 的字段约定&lt;/h2&gt;

&lt;p&gt;虽然你可以在 Query 和 Mutation 类型里添加任意字段，但是根据语义，应当把不对数据造成修改的字段放在 Query 类型里，而把对数据造成修改的字段放在 Mutation 里。&lt;/p&gt;

&lt;p&gt;可以这么理解，查询 Mutation 里的字段实际也是一次「查询」，但是这次查询会对数据造成修改。&lt;/p&gt;

&lt;p&gt;以下是一个简单的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Query {
  me: User
}

type Mutation {
  changeMyName(name: String): User
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;resolver&#34;&gt;Resolver&lt;/h2&gt;

&lt;p&gt;Resolver 实际上是一个函数。当我们执行某条 GraphQL 语句时（当然，通常是在 Server 上），会通过执行对应的 Resolver 函数来获取查询的字段的。&lt;/p&gt;

&lt;p&gt;拿第一节的例子，Schema 为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Query {
  hello: String
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们接下来实现一个用来「查询 Query 类型里字段 hello」的 Resolver。例如我们让这个字段返回 &amp;ldquo;Hello world!&amp;rdquo; 字符串：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export const resolverMap: IResolvers = {
  Query: {
    hello: {
      resolve: () =&amp;gt; (&amp;quot;Hello world!&amp;quot;),
    },
  },
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里用了一个双层的 Map(/Object) 来装载所有 Resolver，实际上第一层用来索引类型，第二层用来索引类型中的字段。&lt;/p&gt;

&lt;p&gt;而上面键 resolve 对应的函数就是 hello 这个字段的 Resolver 函数。依据 Schema 的声明它需要返回了一个字符串。&lt;/p&gt;

&lt;p&gt;我们再来看下如果查询的字段是复杂类型的情况。假设 Schema 为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Query {
  me: User
}

type User {
  name: String
  friend: User
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;User 类型里的 friend 字段返回的是一个 User 类型，那么就可能出现下面这样循环嵌套的 GraphQL 语句：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;query {
  me {
    name
    friend {
      name
      friend {
        name
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那我们怎样为这样的语句进行 Resolve 呢？&lt;/p&gt;

&lt;p&gt;注意前面说到 Resolver 表。我们可以在表里添加 User 类型，然后为 friend 字段单独添加一个 Resolver：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export const resolverMap: IResolvers = {
  Query: {
    me: {
      resolve: () =&amp;gt; ({ name: &amp;quot;Mark&amp;quot; }),
    },
  },
  User: {
    friend: {
      resolve: (parent) =&amp;gt;
        ({ name: (`${parent.name}&#39;s friend`) }),
    },
  },
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么，前面的 GraphQL 语句里的三个 name 会分别返回：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Mark
Mark&#39;s friend
Mark&#39;s friend&#39;s friend
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，这里的 Resolver 函数使用了 parent 参数，它实际上是父字段的返回值。完整的函数签名可以在 &lt;a href=&#34;https://www.apollographql.com/docs/graphql-tools/resolvers#Resolver-function-signature&#34;&gt;官方文档&lt;/a&gt; 这里看到。&lt;/p&gt;

&lt;p&gt;执行整个 GraphQL 语句的逻辑就是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;访问到 Query 类型里的 me 字段，使用 &lt;code&gt;resolverMap[&amp;quot;Query&amp;quot;][&amp;quot;me&amp;quot;]&lt;/code&gt; 来获得 User 里的字段的值。&lt;/li&gt;
&lt;li&gt;该次 Resolve 只返回了 name 字段的值，但是 GraphQL 语句中还查询了 friend 字段。&lt;/li&gt;
&lt;li&gt;friend 是 User 类型里的字段，所以继续使用 &lt;code&gt;resolverMap[&amp;quot;User&amp;quot;][&amp;quot;friend&amp;quot;]&lt;/code&gt; 来获取 friend 字段的返回值。&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;留道思考题：如果在 &lt;code&gt;[&amp;quot;Query&amp;quot;][&amp;quot;me&amp;quot;]&lt;/code&gt; 这个 Resolver 里返回的是 &lt;code&gt;{ name: &amp;quot;Mark&amp;quot;, friend: &amp;quot;Tony&amp;quot; }&lt;/code&gt; 那最终查询结果会是什么呢？&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;Schema：用于声明 GraphQL 语句能够查询什么样的数据。&lt;/p&gt;

&lt;p&gt;GraphQL 语句：用于描述需要查询哪些数据。&lt;/p&gt;

&lt;p&gt;Resolver：用于返回需要的数据。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Docker, Serverless, GraphQL</title>
      <link>https://nekocode.cn/posts/docker_serverless_graphql/</link>
      <pubDate>Mon, 10 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://nekocode.cn/posts/docker_serverless_graphql/</guid>
      <description>

&lt;p&gt;最近被 Backend、DevOps 的一些新概念震撼到了。&lt;/p&gt;

&lt;h2 id=&#34;docker&#34;&gt;Docker&lt;/h2&gt;

&lt;p&gt;Docker 应该是目前 DevOps 界最火的工具了。&lt;/p&gt;

&lt;p&gt;早在前几年，我就开始使用 Docker 了。通过 Docker 为公司搭建 Maven 和 Jenkins 服务，然后构建用于编译 Android 项目的 Docker Image 提供给 Jenkins 使用。&lt;/p&gt;

&lt;p&gt;对于曾经尝试过 Deployment 地狱的人，Docker 的便捷让我对它的印象十分好。&lt;/p&gt;

&lt;p&gt;而今年，借助 Docker Compose，我更在我的服务器上成功用几句命令就搭建了一系列工具。仅仅是写写 YAML 配置，就可以快速轻松地部署到任意服务器上，这得有多爽。甚至还包括以下一些自动化的事情：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通过 &lt;a href=&#34;https://github.com/jwilder/nginx-proxy&#34;&gt;jwilder/nginx-proxy&lt;/a&gt; 自动为其它 Docker 容器配置 Nginx 代理；&lt;/li&gt;
&lt;li&gt;通过 &lt;a href=&#34;https://github.com/JrCs/docker-letsencrypt-nginx-proxy-companion&#34;&gt;jrcs/letsencrypt-nginx-proxy-companion&lt;/a&gt; 自动创建 Let&amp;rsquo;s Encrypt 证书并配置，轻松支持 Https。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果是在远古时代，对一个非专业 DevOps 工程师而言，即使不考虑系统和软件之间的兼容问题，要手动完成上述的所有部署操作也是十分麻烦的。要是遇到要把所有服务迁移或复制到其他机器上这种事情，估计得抓狂。&lt;/p&gt;

&lt;p&gt;来看看我的 Docker Compose YAML 吧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Nginx-Proxy:
  image: daocloud.io/daocloud/nginx-proxy:latest
  privileged: false
  restart: always
  ports:
    - 80:80
    - 443:443
  volumes:
    - /root/nginx-proxy/certs:/etc/nginx/certs:ro
    - /root/nginx-proxy/vhost:/etc/nginx/vhost.d
    - /root/nginx-proxy/html:/usr/share/nginx/html
    - /var/run/docker.sock:/tmp/docker.sock:ro
  labels:
    com.github.jrcs.letsencrypt_nginx_proxy_companion.nginx_proxy: &#39;true&#39;
LetsEncrypt:
  image: jrcs/letsencrypt-nginx-proxy-companion
  restart: always
  volumes:
    - /root/nginx-proxy/certs:/etc/nginx/certs:rw
    - /root/nginx-proxy/vhost:/etc/nginx/vhost.d
    - /root/nginx-proxy/html:/usr/share/nginx/html
    - /var/run/docker.sock:/var/run/docker.sock:ro
Gitlab:
  image: gitlab/gitlab-ce:11.2.1-ce.0
  privileged: false
  restart: always
  ports:
    - 80
    - 443
    - 22
  volumes:
    - /root/gitlab/config:/etc/gitlab
    - /root/gitlab/logs:/var/log/gitlab
    - /root/gitlab/data:/var/opt/gitlab
  environment:
    VIRTUAL_HOST: git.nekocode.cn
    LETSENCRYPT_HOST: git.nekocode.cn
    LETSENCRYPT_EMAIL: nekocode.cn@gmail.com
    GITLAB_OMNIBUS_CONFIG: |
      gitlab_rails[&#39;smtp_enable&#39;] = true
      gitlab_rails[&#39;smtp_address&#39;] = &amp;quot;smtpdm.aliyun.com&amp;quot;
      gitlab_rails[&#39;smtp_port&#39;] = 465
      gitlab_rails[&#39;smtp_user_name&#39;] = &amp;quot;git@nekocode.cn&amp;quot;
      gitlab_rails[&#39;smtp_password&#39;] = &amp;quot;xxxxxx&amp;quot;
      gitlab_rails[&#39;smtp_domain&#39;] = &amp;quot;smtpdm.aliyun.com&amp;quot;
      gitlab_rails[&#39;smtp_authentication&#39;] = &amp;quot;login&amp;quot;
      gitlab_rails[&#39;smtp_enable_starttls_auto&#39;] = true
      gitlab_rails[&#39;smtp_tls&#39;] = true
      gitlab_rails[&#39;gitlab_email_enabled&#39;] = true
      gitlab_rails[&#39;gitlab_email_from&#39;] = &#39;git@nekocode.cn&#39;
      gitlab_rails[&#39;gitlab_email_display_name&#39;] = &#39;noreply@nekocode.cn&#39;
Gitlab-Runner:
  image: gitlab/gitlab-runner:latest
  container_name: gitlab-runner
  restart: always
  volumes:
    - /root/gitlab-runner/confg:/etc/gitlab-runner
    - /var/run/docker.sock:/var/run/docker.sock
Wiki:
  image: blacklabelops/confluence
  privileged: false
  restart: always
  ports:
    - 8090
    - 8091
  environment:
    VIRTUAL_HOST: wiki.nekocode.cn
    VIRTUAL_PORT: 8090
    CONFLUENCE_PROXY_NAME: wiki.nekocode.cn
    CONFLUENCE_PROXY_PORT: 443
    CONFLUENCE_PROXY_SCHEME: https
    LETSENCRYPT_HOST: wiki.nekocode.cn
    LETSENCRYPT_EMAIL: nekocode.cn@gmail.com
PostgresDB:
  image: blacklabelops/postgres
  restart: always
  ports:
    - 5432:5432
  environment:
    POSTGRES_DB: postgresdb
    POSTGRES_USER: admin
    POSTGRES_PASSWORD: admin123
    POSTGRES_ENCODING: UTF8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;感谢 Docker 和社区的发展，让快速轻松地部署软件成为可能。所以请不要再去手工部署或写兼容性差的 Deploy 脚本了。你需要拥抱 Docker / 容器技术。&lt;/p&gt;

&lt;h2 id=&#34;serverless&#34;&gt;Serverless&lt;/h2&gt;

&lt;p&gt;Docker 的火热更是推动了一些其他技术的发展。&lt;/p&gt;

&lt;p&gt;AWS 在 2014 年底发布了新服务 Lambda，它能借助 Docker 来执行函数，直接把云计算的最小单位缩小到了函数级别！从此，Serverless 的概念开始火热起来。&lt;/p&gt;

&lt;p&gt;前几年刚接触 BaaS 已经让我有些小惊喜了，通过 BaaS，即使是前端开发，也可以低成本地自己去构造一个轻量级的后端服务。而今年刚接触到 Serverless 时更让我震撼，它让开发者能用比更低的成本来开发一个更 Scalable 的后端服务。&lt;/p&gt;

&lt;p&gt;成本低、Scalable、NoOps 是 Lambda 的几个优点。开发者可以花更多精力去关注业务，而不必关心所有硬件、架构、部署相关的细节。你不用再思考使用什么框架、怎么组织代码能让你的服务 Scalability 更强，也不用关心怎么部署 / 负载均衡才能扛住新一轮的流量增长。&lt;/p&gt;

&lt;h2 id=&#34;graphql&#34;&gt;GraphQL&lt;/h2&gt;

&lt;p&gt;GraphQL 是其中一个我认为会对目前 C/S 开发产生革命性作用的技术。&lt;/p&gt;

&lt;p&gt;客户端通过服务端「预设」的 Api 来查询、修改服务端数据。这种设计实在是太死板了，即使遵循 Restful 风格设计，也会遇到很多需要前后端磨合 / 不断沟通的问题。而 Api 版本迭代、前后兼容的问题也会让人抓狂。&lt;/p&gt;

&lt;p&gt;由于接口需要设计和维护，会消耗后端开发的很多时间。而 GraphQL 可以帮你释放这部分时间，你可以不用再面向接口开发了，可以花更多时间在业务模型、数据库设计上，需要查询或修改什么数据让前端自己去描述吧。&lt;/p&gt;

&lt;p&gt;顺便推荐下 &lt;a href=&#34;https://www.prisma.io/&#34;&gt;Prisma&lt;/a&gt; ，它能帮你快速在已有数据库上搭建 GraphQL 服务。目前我在尝试把它同时搭在某个 MySQL 和 MongoDB 上面。&lt;/p&gt;

&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;

&lt;p&gt;记录的都是一些零碎、微小的经验。 PS，对于「精益创业」的中小型团队，这些技术好像都蛮适合的，短期来看开发快、成本低，长期来看 Scalable。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>「二零一七年」的总结</title>
      <link>https://nekocode.cn/posts/summary_of_2017/</link>
      <pubDate>Thu, 15 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://nekocode.cn/posts/summary_of_2017/</guid>
      <description>&lt;p&gt;为什么二月十五才写去年的总结？一，懒；二，正处农历大年三十，可以诡辩地说二零一七在农历上仍未完结。&lt;/p&gt;

&lt;p&gt;二零一七，于我而言是十分重要的一年。&lt;/p&gt;

&lt;p&gt;一五、一六年我跟着几个刚毕业的朋友一起创业，从获得千万级风投，到最终资金链断裂，总算结束了我个人的所谓「大学生创业」之路。而一七年初，我入职了知乎。这是一家已经连续创业七年多的公司，而我一直是知乎的重度用户。&lt;/p&gt;

&lt;p&gt;把之前创业的经历，和在知乎这一年的经历联系在一起，让我感触十分大。我个人的观点是，「大学生创业」、「九零、零零后创业」等，这些只是资本包装起来的词汇。风口上的标签、媒体口味的变化、可观的投资回报率让很多投资者突然对这块市场虎视眈眈。能够在一个早期创业团队上买入股份，然后对团队进行包装和宣传，就有可能再融个几轮卖出个好价钱了。这种已成套路的投资，让大学生创业市场近几年变得熙熙攘攘。&lt;/p&gt;

&lt;p&gt;但是，缺乏从业经验、市场眼光、风险控制能力、精英化管理能力的大学生团队，不管是在创业的哪一个环节上遭遇到了问题，都可能会是对团队的致命一击。如果我是投资家，我是万万不敢重仓大学生创业团队的，因为在我看来，目前以及未来仍旧是「精英创业」的时代。而那些投资大学生团队的人，他们肯扔钱其实主要出于三个原因：一，容易用很低的价格买入大量的股份，因为大多数大学生团队在面对资本的时候，根本没有任何谈资。二、大学生团队运营成本极低，只要不乱烧钱，想要活久一些太容易了。三，前面就说过了，媒体的口味决定了大学生团队更容易被包装起来，这个其实主要看 CEO，可以参考「余佳文」这类典例（但我个人并不喜欢被这类人 Lead）。&lt;/p&gt;

&lt;p&gt;而一七年，我能明显感觉到媒体的口味开始再度产生变化，之前一向喜欢鼓吹大学生创业的媒体开始倒戈相向，反而频频开始对大学生创业项目发起质疑、反讽。这让我学习到了三件事：一，资本市场都是贪婪、黑暗的。二，媒体的能力变得日益可怕，创造错误的信息差也能挣钱。三，风口是会改变的（或者说具有周期性），虽然跟着泡沫涨能吃上猪肉，但你得预测到它什么时候会爆。&lt;/p&gt;

&lt;p&gt;写到这顺带把一五、一六年的一些看法也总结了。接下来说回二零一七这一年。&lt;/p&gt;

&lt;p&gt;我前面说到了，入职知乎的这一年于我而言十分重要。一来是遇到了很多职场精英，颠覆了我很多过往的看法。他们中有极具有 Geek 精神的工程师、年投资回报过百万的工程师、极具逻辑能力的 Leader。在这个平台上，其实能明显感觉到，相对于很多其他人，自己能力还十分不足，但值得庆幸的是自己的职业生涯还早，并且自己能明显意识到自己的一些问题所在。我本身算是个 Workaholic，希望之后方向正确的话，勤能补拙。&lt;/p&gt;

&lt;p&gt;二来是由于「实际收入 / 工作时间」比的提高，让我有更多精力去学习、探讨一些技术以外的东西，譬如投资。相对于之前泡沫化的收入，其实到手的收入对于一个风险承担能力弱的穷人而言更踏实。创业的话，干个几年活，最终期权变废纸的概率太大了。当然我不是抵抗创业，我骨子里是喜欢创业的，而且我也崇拜硅谷创业精神。但所谓厚积薄发，我认为目前并不是 Allin 创业的时机，因为我根本没有多少资本去支撑高风险的持续创业（这里的资本包括经验、眼界、资金等）。不过我相信，未来我应该会重新投入其中。当然，目前在知乎也是一种创业，但我想做的其它事还多着。&lt;/p&gt;

&lt;p&gt;技术相关的事在这个博客上不想费太多笔墨，简单总结下：大多数达到了我对二零一七的心里预期，稍微提高了自己在社区的影响力（我在 Github 社区的一些成就可以在 &lt;a href=&#34;http://git-awards.com/users/nekocode&#34;&gt;这里&lt;/a&gt; 查看）。希望二零一八可以持续提高自己的能力和影响力，并且能在一些其它的领域（新技术、Web）获得新的成就。&lt;/p&gt;

&lt;p&gt;接下来我想讲下「投资」。&lt;/p&gt;

&lt;p&gt;很多人喜欢把它称作「理财」，这其实是每个人都会接触到的事情，即使是你把钱全部放在银行里，你也是在做一项投资，只不过你是把钱投给了风险和投资回报率都相对较低的银行（银行也会拿你的钱去投资其它产品、或借贷出去来获得利润）。在二零一七的下半年，我开始大量接触了投资相关的知识，一来是市场突然一片大好，以及投资热潮的突然刮起（这其实是个相当危险的讯号），二来是我创业的时候做的是新三板相关的内容，耳濡目染也开始对金融行业产生兴趣。&lt;/p&gt;

&lt;p&gt;比较狗血的是，我入场的时机几乎是最差的。二零一八初，我投资了些数字货币，没想到不到半个月比特币的价格就腰斩了。而最近美股市场也一片哀嚎，可以看出经济可能要到周期的拐点了，也就是泡沫要爆了。而我恰好在最高点入场了，。。。&lt;/p&gt;

&lt;p&gt;经历被割韭菜的洗礼后，上个月，我在知乎想法上发表了一些 &lt;a href=&#34;https://www.zhihu.com/pin/938432484480962560&#34;&gt;对数字货币的看法&lt;/a&gt;，现在可以在这里再补充一些。首先，大部分经济学家都认为数字货币是泡沫，而股神巴菲特也不看好，并坦言很乐意买入五年期的加密货币看空期权。为什么是五年期？因为即使是巴菲特也没法准确预言这个泡沫会什么时候爆，但他觉得五年后必然会爆。&lt;/p&gt;

&lt;p&gt;但是「天下熙熙皆为利来，天天攘攘皆为利往」，由于人性的贪婪，没人知道这个泡沫会怎么发展，虽然近期腰斩之后目前又开始回升了，但是说实话，我不建议再投钱进去。目前的币市由于缺乏公信机关的监管基本已沦为赌场，而目前能支撑起价格的，大部分还是黑市的需求，和一些尚未对社会产生实际价值的概念。&lt;/p&gt;

&lt;p&gt;在这次经历里，我犯的最严重的错误就是简单地认为「看好某样事物」就值得投资，然而这其实只是最基础的一个判断因素。假设市场里有十个人，你是第八个看好某件事物的，那么你可能就已经站在泡沫的顶端了。所以看涨某件事物，首先你得足够早（这其实是个信息差的问题）。其次，你得准确预判它的价值是被低估了，还是已经产生泡沫了。&lt;/p&gt;

&lt;p&gt;但这绝非易事。只能不断学习和尝试。最近春节无聊，刚好也沉迷上了玩德州扑克，这其实可以看作是一个微型的投资训练了，取胜需要你有足够的情绪和风险控制能力。其实，很多时候投资和 投机 / 赌博 是有共通点的，投资也有赚有亏，能稳住牌面最终赢钱离场，那你就是赢家。&lt;/p&gt;

&lt;p&gt;二零一七要记录的也就那么多。希望新的一年能有更多新的进步。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Archives</title>
      <link>https://nekocode.cn/archives/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://nekocode.cn/archives/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>