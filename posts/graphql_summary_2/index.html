<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
	<title>GraphQL 纪要（二）</title>
	
	<meta name="description" content="">
	<meta name="image" content="">
	
	<meta itemprop="name" content="GraphQL 纪要（二）">
	<meta itemprop="description" content="">
	<meta itemprop="image" content="">
	
	<meta name="og:title" content="GraphQL 纪要（二）">
	<meta name="og:description" content="">
	
	<meta name="og:url" content="https://nekocode.cn/posts/graphql_summary_2/">
	<meta name="og:site_name" content="GraphQL 纪要（二）">
	<meta name="og:type" content="article">
	
	<meta name="article:tag" content="Markdown ">
	<link rel="stylesheet" type="text/css" href="https://nekocode.cn/css/style.css">
	<link rel="stylesheet" type="text/css" href="https://nekocode.cn/css/fonts.css" />
	
	
	
	
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-129020994-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

	
</head>

<body>

<header>
	<div class="head-navi">
		
		<a href="https://nekocode.cn/">杨凡</a>
		
		
		
		
		<a href="https://nekocode.cn/about">About</a>
		
	</div>
	
	<a href="https://nekocode.cn/posts/index.xml" style="float:right;"><i class="icon-rss"></i></a>
</header>


<div class="content">
  <h1>GraphQL 纪要（二）</h1>
  <aside>Written on 2018/10/20.</aside>
  <p>

<h2 id="resolver-设计">Resolver 设计</h2>

<p>我们可能会在 Resolver 里做一些耗时的操作（例如操作 Database）。为了保证我们尽可能快地响应用户的查询，我们必须保证只对那些用户需要的字段进行查询。</p>

<p>首先举个反例，我们定义了以下的 Schema：</p>

<pre><code>type Query {
  getPost: Post
}

type Post {
  title: String
  authorName: String
}
</code></pre>

<p>对应的 Resolver Map：</p>

<pre><code>export const resolverMap: IResolvers = {
  Query: {
    getPost: {
      resolve: () =&gt; {
        const post = queryPostDbTable();
        const author = queryUserDbTable(post.authorId);
        return {
          title: post.title,
          authorName: author.name;,
        };
      },
    },
  },
};
</code></pre>

<p>可以看到，在 getPost 字段的 Resolver 里会查询 Post 和 User 表。糟糕的是，即便用户并没有查询 authorName 字段，在获取 getPost 字段的时候也会查询 User 表。这造成了冗余的数据库操作。</p>

<p>为了解决这个问题，我们应当把 authorName 字段的获取放到另一个 Resolver 里。例如：</p>

<pre><code>export const resolverMap: IResolvers = {
  Query: {
    getPost: {
      resolve: () =&gt; {
        return queryPostDbTable();
      },
    },
  },
  Post: {
    authorName: {
      resolve: (post) =&gt; {
        return queryUserDbTable(post.authorId).name;
      },
    },
  },
};
</code></pre>

<p>这样可以只在用户查询到 authorName 字段时才去查询 User 表。</p>

<p>现在再假设一下，如果 Post 里还要返回用户头像路径的话，例如 Schema 为：</p>

<pre><code>type Post {
  title: String
  authorName: String
  authorAvatar: String
}
</code></pre>

<p>这种情况，Resolver 又不好设计了。</p>

<p>实际上，查询一次 User 表就可以同时获得 authorName 和 authorAvatar 字段了。但如果按照上面的设计，把这两个字段放在单独的 Resolver 里的话，那么如果用户同时查询这两个字段，会查询两次 User 表。</p>

<p>所以说这种扁平的 Schema 设计其实是不好，更好的设计应该是：</p>

<pre><code>type Post {
  title: String
  author: User
}

type User {
  name: String
  avatar: String
}
</code></pre>

<p>对应 Resolver Map：</p>

<pre><code>export const resolverMap: IResolvers = {
  Query: {
    getPost: {
      resolve: () =&gt; {
        return queryPostDbTable();
      },
    },
  },
  Post: {
    author: {
      resolve: (post) =&gt; {
        return queryUserDbTable(post.authorId);
      },
    },
  },
};
</code></pre>

<h2 id="graphql-orver-prisma">GraphQL Orver Prisma</h2>

<p>Prisma 是基于 GraphQL 的最流行的 ORM 框架之一。我们可以使用 Prisma 提供的类似 GraphQL Schema 的语法来定义我们的所有 Model，然后 Prisma 会帮我们在数据库中建立对应的表和列，并生成一个包含增删查改这些 Model 功能的 GraphQL 服务。</p>

<p>简单来说，通过 Prisma，我们可以使用 GraphQL 语句来操作数据库。</p>

<p>而使用 Prisma 的好处是，我们可以 Prisma 上再搭建一层 GraphQL 服务来处理更高层的业务逻辑，这样很多操作 Model 的 GraphQL 请求可以直接转发给 Prisma 处理。在定义 Schema 时，很多 Type 甚至可以复用 Prisma 生成的。</p>

<p>有兴趣的可以看下我写的 <a href="https://github.com/nekocode/typescript-graphql-over-prisma">DEMO</a>。它能帮助你快速搭建一个后端服务。</p>

<h2 id="其它">其它</h2>

<p>实际上，无论在功能还是性能上，GraphQL 都是特别薄的一层，它所做的仅仅是把 GraphQL 语句解析成 AST，然后执行对应的 Resolver 而已。你甚至可以把它作为 Api Gateway，用它来包裹其它微服务的接口。</p>

<p>而对比过往 Rest 的接口设计，GraphQL 作为一门「语言」描述明显能力更强。你可以在一条 GraphQL 语句里按需查询你所有需要的数据，仅需要一次网络请求，而如果你的 Resolver 设计的足够好的话，不会像 Rest 接口那样可能造成冗余的查询。</p>
</p>
</div>


<nav class="post-nav">
  <div><a href="https://nekocode.cn/posts/graphql_summary/"><i class="icon-left-open"></i>GraphQL 纪要</a></div>
  <div><a href="https://nekocode.cn/posts/abused_gui_design_pattern/">被滥用的 GUI 设计模式<i class="icon-right-open"></i></a></div>
</nav>
<script type="text/javascript">
document.addEventListener('keyup', function(e) {
  if (e.target.nodeName.toUpperCase() != 'BODY') return;
  var url = false;
  if (e.which == 37) {  
    
    url = 'https:\/\/nekocode.cn\/posts\/graphql_summary\/';
    
  } else if (e.which == 39) {  
    
    url = 'https:\/\/nekocode.cn\/posts\/abused_gui_design_pattern\/';
    
  }
  if (url) window.location = url;
});
</script>


<a id="scroll-to-top" href="#" style="display:none;"><i class="icon-up-open"></i></a>
<script type="text/javascript">
var scroll_to_top = document.getElementById('scroll-to-top');
window.onscroll = function(ev) {
  var  scrollTop = window.pageYOffset || document.body.scrollTop;
  if (scrollTop > 200) {
    scroll_to_top.style.display = 'block';
  } else {
    scroll_to_top.style.display = 'none';   
  }
};
scroll_to_top.onclick = function () {
  window.scrollTo({top: 0});
}
</script>


<section class="comments">
    <div id="disqus_thread"></div>
    <script>
    var disqus_config = function () {
    
    this.page.url = "https:\/\/nekocode.cn" +  location.pathname;
    
    
    };
    (function() { 
    var d = document, s = d.createElement('script');
    s.src = 'https://nekocode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>


<footer>
	<p>&copy; 2018 All rights reserved.   | <a href="https://github.com/nekocode/nekocode.cn/">Source code</a></p>
</footer>
</body>
</html>
