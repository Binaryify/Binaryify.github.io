<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
	<title>GraphQL 纪要</title>
	
	<meta name="description" content="">
	<meta name="image" content="">
	
	<meta itemprop="name" content="GraphQL 纪要">
	<meta itemprop="description" content="">
	<meta itemprop="image" content="">
	
	<meta name="og:title" content="GraphQL 纪要">
	<meta name="og:description" content="">
	
	<meta name="og:url" content="https://nekocode.cn/posts/graphql_summary/">
	<meta name="og:site_name" content="GraphQL 纪要">
	<meta name="og:type" content="article">
	
	<meta name="article:tag" content="Markdown ">
	<link rel="stylesheet" type="text/css" href="https://nekocode.cn/css/style.css">
	<link rel="stylesheet" type="text/css" href="https://nekocode.cn/css/fonts.css" />
	
	
	
	
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-129020994-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

	
</head>

<body>

<header>
	<div class="head-navi">
		
		<a href="https://nekocode.cn/">杨凡</a>
		
		
		
		
		<a href="https://nekocode.cn/about">About</a>
		
	</div>
	
	<a href="https://nekocode.cn/posts/index.xml" style="float:right;"><i class="icon-rss"></i></a>
</header>


<div class="content">
  <h1>GraphQL 纪要</h1>
  <aside>Written on 2018/10/19.</aside>
  <p>

<h2 id="schema-graphql-语句">Schema &amp; GraphQL 语句</h2>

<p>GraphQL 是一门查询语言，使用它可以描述你需要哪些数据。而 Schema 则是用于声明你能够查询什么样的数据。</p>

<p>举个例子，下面的是 Schema：</p>

<pre><code>type Query {
  hello: String
}
</code></pre>

<p>通过以上 Schema 的声明，你可以写下这么一条 GraphQL 查询语句：</p>

<pre><code>query {
  hello
}
</code></pre>

<h2 id="schema">Schema</h2>

<p>Schema 里主要有两个核心的概念，类型（Type）和字段（Field）。举个例子：</p>

<pre><code>type User {
  name: String
}
</code></pre>

<p>上面定义了一个名为 User 的类型，并且这个类型里包含了一个叫做 name 的字段。
注意，字段必须声明类型，可以声明为 Int、String 这类基础类型，也可以声明为自定义的类型。另外，字段是可以包含参数的，这让它看起来有点像函数：</p>

<pre><code>type User {
  name: String
  posts(count: Int): [Post]
}

type Post {
  title: String
}
</code></pre>

<p>例如这里 User 类型里的 posts 字段，它接受一个名为 count 的参数并返回一个 Post 类型的列表。</p>

<h2 id="schema-里的-query-和-mutation-类型">Schema 里的 Query 和 Mutation 类型</h2>

<p>在 Schema 里面有两个约定的类型：</p>

<pre><code>type Query {
}

type Mutation {
}
</code></pre>

<p>我们假设，任何 GraphQL 语句都其实是在查询 Document 对象的子字段，而 Document 里面有且只有以下两个直接子字段：</p>

<pre><code>type Document {
  query: Query
  mutation: Mutation
}
</code></pre>

<p>想要在 GraphQL 语句中查询其它字段，只能把要查询的字段放到 Query 和 Mutation 类型里面。例如我们想添加一个用来查询用户信息的字段，那我们可以在 Query 类型里添加一个 me 字段：</p>

<pre><code>type Query {
  me: User
}

type User {
  name: String
}
</code></pre>

<p>那么用户就可以用下面的 GraphQL 语句来查询自己的名称了：</p>

<pre><code>query {
  me {
    name
  }
}
</code></pre>

<p>需要注意的是，这里的 query 是字段名，返回的是一个 Query 类型。me 是 Query 类型里的字段，而 name 是 User 类型里的字段。</p>

<h2 id="query-mutation-的字段约定">Query &amp; Mutation 的字段约定</h2>

<p>虽然你可以在 Query 和 Mutation 类型里添加任意字段，但是根据语义，应当把不对数据造成修改的字段放在 Query 类型里，而把对数据造成修改的字段放在 Mutation 里。</p>

<p>可以这么理解，查询 Mutation 里的字段实际也是一次「查询」，但是这次查询会对数据造成修改。</p>

<p>以下是一个简单的例子：</p>

<pre><code>type Query {
  me: User
}

type Mutation {
  changeMyName(name: String): User
}
</code></pre>

<h2 id="resolver">Resolver</h2>

<p>Resolver 实际上是一个函数。当我们执行某条 GraphQL 语句时（当然，通常是在 Server 上），会通过执行对应的 Resolver 函数来获取查询的字段的。</p>

<p>拿第一节的例子，Schema 为：</p>

<pre><code>type Query {
  hello: String
}
</code></pre>

<p>我们接下来实现一个用来「查询 Query 类型里字段 hello」的 Resolver。例如我们让这个字段返回 &ldquo;Hello world!&rdquo; 字符串：</p>

<pre><code>export const resolverMap: IResolvers = {
  Query: {
    hello: {
      resolve: () =&gt; (&quot;Hello world!&quot;),
    },
  },
};
</code></pre>

<p>这里用了一个双层的 Map(/Object) 来装载所有 Resolver，实际上第一层用来索引类型，第二层用来索引类型中的字段。</p>

<p>而上面键 resolve 对应的函数就是 hello 这个字段的 Resolver 函数。依据 Schema 的声明它需要返回了一个字符串。</p>

<p>我们再来看下如果查询的字段是复杂类型的情况。假设 Schema 为：</p>

<pre><code>type Query {
  me: User
}

type User {
  name: String
  friend: User
}
</code></pre>

<p>User 类型里的 friend 字段返回的是一个 User 类型，那么就可能出现下面这样循环嵌套的 GraphQL 语句：</p>

<pre><code>query {
  me {
    name
    friend {
      name
      friend {
        name
      }
    }
  }
}
</code></pre>

<p>那我们怎样为这样的语句进行 Resolve 呢？</p>

<p>注意前面说到 Resolver 表。我们可以在表里添加 User 类型，然后为 friend 字段单独添加一个 Resolver：</p>

<pre><code>export const resolverMap: IResolvers = {
  Query: {
    me: {
      resolve: () =&gt; ({ name: &quot;Mark&quot; }),
    },
  },
  User: {
    friend: {
      resolve: (parent) =&gt;
        ({ name: (`${parent.name}'s friend`) }),
    },
  },
};
</code></pre>

<p>那么，前面的 GraphQL 语句里的三个 name 会分别返回：</p>

<pre><code>Mark
Mark's friend
Mark's friend's friend
</code></pre>

<p>注意，这里的 Resolver 函数使用了 parent 参数，它实际上是父字段的返回值。完整的函数签名可以在 <a href="https://www.apollographql.com/docs/graphql-tools/resolvers#Resolver-function-signature">官方文档</a> 这里看到。</p>

<p>执行整个 GraphQL 语句的逻辑就是：</p>

<ul>
<li>访问到 Query 类型里的 me 字段，使用 <code>resolverMap[&quot;Query&quot;][&quot;me&quot;]</code> 来获得 User 里的字段的值。</li>
<li>该次 Resolve 只返回了 name 字段的值，但是 GraphQL 语句中还查询了 friend 字段。</li>
<li>friend 是 User 类型里的字段，所以继续使用 <code>resolverMap[&quot;User&quot;][&quot;friend&quot;]</code> 来获取 friend 字段的返回值。</li>
<li>&hellip;</li>
</ul>

<p>留道思考题：如果在 <code>[&quot;Query&quot;][&quot;me&quot;]</code> 这个 Resolver 里返回的是 <code>{ name: &quot;Mark&quot;, friend: &quot;Tony&quot; }</code> 那最终查询结果会是什么呢？</p>

<h2 id="总结">总结</h2>

<p>Schema：用于声明 GraphQL 语句能够查询什么样的数据。</p>

<p>GraphQL 语句：用于描述需要查询哪些数据。</p>

<p>Resolver：用于返回需要的数据。</p>
</p>
</div>


<nav class="post-nav">
  <div><a href="https://nekocode.cn/posts/docker_serverless_graphql/"><i class="icon-left-open"></i>Docker, Serverless, GraphQL</a></div>
  <div><a href="https://nekocode.cn/posts/graphql_summary_2/">GraphQL 纪要（二）<i class="icon-right-open"></i></a></div>
</nav>
<script type="text/javascript">
document.addEventListener('keyup', function(e) {
  if (e.target.nodeName.toUpperCase() != 'BODY') return;
  var url = false;
  if (e.which == 37) {  
    
    url = 'https:\/\/nekocode.cn\/posts\/docker_serverless_graphql\/';
    
  } else if (e.which == 39) {  
    
    url = 'https:\/\/nekocode.cn\/posts\/graphql_summary_2\/';
    
  }
  if (url) window.location = url;
});
</script>


<a id="scroll-to-top" href="#" style="display:none;"><i class="icon-up-open"></i></a>
<script type="text/javascript">
var scroll_to_top = document.getElementById('scroll-to-top');
window.onscroll = function(ev) {
  var  scrollTop = window.pageYOffset || document.body.scrollTop;
  if (scrollTop > 200) {
    scroll_to_top.style.display = 'block';
  } else {
    scroll_to_top.style.display = 'none';   
  }
};
scroll_to_top.onclick = function () {
  window.scrollTo({top: 0});
}
</script>


<section class="comments">
    <div id="disqus_thread"></div>
    <script>
    var disqus_config = function () {
    
    this.page.url = "https:\/\/nekocode.cn" +  location.pathname;
    
    
    };
    (function() { 
    var d = document, s = d.createElement('script');
    s.src = 'https://nekocode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>


<footer>
	<p>&copy; 2019 All rights reserved.   | <a href="https://github.com/nekocode/nekocode.cn/">Source code</a></p>
</footer>
</body>
</html>
