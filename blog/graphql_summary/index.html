<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>GraphQL 纪要 - 杨凡</title>
    <meta property="og:title" content="GraphQL 纪要 - 杨凡">
    

    
      
    

    

    
    




    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  
  <body class="blog">
    <header class="masthead">
      <h1><a href="/">杨凡</a></h1>

<p class="tagline">Personal blog of Mark Yueng.</p>

      <nav class="menu">
        <input id="menu-check" type="checkbox" />
        <label id="menu-label" for="menu-check" class="unselectable">
          <span class="icon close-icon">✕</span>
          <span class="icon open-icon">☰</span>
          <span class="text">Menu</span>
        </label>
        <ul>
        
        
        <li><a href="/">Home</a></li>
        
        <li><a href="/project-gallery">Project Gallery</a></li>
        
        <li><a href="/resume.pdf">Resume</a></li>
        
        
        </ul>
      </nav>
    </header>

    <article class="main">
      <header class="title">
      
<h1>GraphQL 纪要</h1>

<h3>
  2018-10-19</h3>
<hr>


      </header>





<h2 id="schema-graphql-语句">Schema &amp; GraphQL 语句</h2>

<p>GraphQL 是一门查询语言，使用它可以描述你需要哪些数据。而 Schema 则是用于声明你能够查询什么样的数据。</p>

<p>举个例子，下面的是 Schema：</p>

<pre><code>type Query {
  hello: String
}
</code></pre>

<p>通过以上 Schema 的声明，你可以写下这么一条 GraphQL 查询语句：</p>

<pre><code>query {
  hello
}
</code></pre>

<h2 id="schema">Schema</h2>

<p>Schema 里主要有两个核心的概念，类型（Type）和字段（Field）。举个例子：</p>

<pre><code>type User {
  name: String
}
</code></pre>

<p>上面定义了一个名为 User 的类型，并且这个类型里包含了一个叫做 name 的字段。
注意，字段必须声明类型，可以声明为 Int、String 这类基础类型，也可以声明为自定义的类型。另外，字段是可以包含参数的，这让它看起来有点像函数：</p>

<pre><code>type User {
  name: String
  posts(count: Int): [Post]
}

type Post {
  title: String
}
</code></pre>

<p>例如这里 User 类型里的 posts 字段，它接受一个名为 count 的参数并返回一个 Post 类型的列表。</p>

<h2 id="schema-里的-query-和-mutation-类型">Schema 里的 Query 和 Mutation 类型</h2>

<p>在 Schema 里面有两个约定的类型：</p>

<pre><code>type Query {
}

type Mutation {
}
</code></pre>

<p>我们假设，任何 GraphQL 语句都其实是在查询 Document 对象的子字段，而 Document 里面有且只有以下两个直接子字段：</p>

<pre><code>type Document {
  query: Query
  mutation: Mutation
}
</code></pre>

<p>想要在 GraphQL 语句中查询其它字段，只能把要查询的字段放到 Query 和 Mutation 类型里面。例如我们想添加一个用来查询用户信息的字段，那我们可以在 Query 类型里添加一个 me 字段：</p>

<pre><code>type Query {
  me: User
}

type User {
  name: String
}
</code></pre>

<p>那么用户就可以用下面的 GraphQL 语句来查询自己的名称了：</p>

<pre><code>query {
  me {
    name
  }
}
</code></pre>

<p>需要注意的是，这里的 query 是字段名，返回的是一个 Query 类型。me 是 Query 类型里的字段，而 name 是 User 类型里的字段。</p>

<h2 id="query-mutation-的字段约定">Query &amp; Mutation 的字段约定</h2>

<p>虽然你可以在 Query 和 Mutation 类型里添加任意字段，但是根据语义，应当把不对数据造成修改的字段放在 Query 类型里，而把对数据造成修改的字段放在 Mutation 里。</p>

<p>可以这么理解，查询 Mutation 里的字段实际也是一次「查询」，但是这次查询会对数据造成修改。</p>

<p>以下是一个简单的例子：</p>

<pre><code>type Query {
  me: User
}

type Mutation {
  changeMyName(name: String): User
}
</code></pre>

<h2 id="resolver">Resolver</h2>

<p>Resolver 实际上是一个函数。当我们执行某条 GraphQL 语句时（当然，通常是在 Server 上），会通过执行对应的 Resolver 函数来获取查询的字段的。</p>

<p>拿第一节的例子，Schema 为：</p>

<pre><code>type Query {
  hello: String
}
</code></pre>

<p>我们接下来实现一个用来「查询 Query 类型里字段 hello」的 Resolver。例如我们让这个字段返回 &ldquo;Hello world!&rdquo; 字符串：</p>

<pre><code>export const resolverMap: IResolvers = {
  Query: {
    hello: {
      resolve: () =&gt; (&quot;Hello world!&quot;),
    },
  },
};
</code></pre>

<p>这里用了一个双层的 Map(/Object) 来装载所有 Resolver，实际上第一层用来索引类型，第二层用来索引类型中的字段。</p>

<p>而上面键 resolve 对应的函数就是 hello 这个字段的 Resolver 函数。依据 Schema 的声明它需要返回了一个字符串。</p>

<p>我们再来看下如果查询的字段是复杂类型的情况。假设 Schema 为：</p>

<pre><code>type Query {
  me: User
}

type User {
  name: String
  friend: User
}
</code></pre>

<p>User 类型里的 friend 字段返回的是一个 User 类型，那么就可能出现下面这样循环嵌套的 GraphQL 语句：</p>

<pre><code>query {
  me {
    name
    friend {
      name
      friend {
        name
      }
    }
  }
}
</code></pre>

<p>那我们怎样为这样的语句进行 Resolve 呢？</p>

<p>注意前面说到 Resolver 表。我们可以在表里添加 User 类型，然后为 friend 字段单独添加一个 Resolver：</p>

<pre><code>export const resolverMap: IResolvers = {
  Query: {
    me: {
      resolve: () =&gt; ({ name: &quot;Mark&quot; }),
    },
  },
  User: {
    friend: {
      resolve: (parent) =&gt;
        ({ name: (`${parent.name}'s friend`) }),
    },
  },
};
</code></pre>

<p>那么，前面的 GraphQL 语句里的三个 name 会分别返回：</p>

<pre><code>Mark
Mark's friend
Mark's friend's friend
</code></pre>

<p>注意，这里的 Resolver 函数使用了 parent 参数，它实际上是父字段的返回值。完整的函数签名可以在 <a href="https://www.apollographql.com/docs/graphql-tools/resolvers#Resolver-function-signature">官方文档</a> 这里看到。</p>

<p>执行整个 GraphQL 语句的逻辑就是：</p>

<ul>
<li>访问到 Query 类型里的 me 字段，使用 <code>resolverMap[&quot;Query&quot;][&quot;me&quot;]</code> 来获得 User 里的字段的值。</li>
<li>该次 Resolve 只返回了 name 字段的值，但是 GraphQL 语句中还查询了 friend 字段。</li>
<li>friend 是 User 类型里的字段，所以继续使用 <code>resolverMap[&quot;User&quot;][&quot;friend&quot;]</code> 来获取 friend 字段的返回值。</li>
<li>&hellip;</li>
</ul>

<p>留道思考题：如果在 <code>[&quot;Query&quot;][&quot;me&quot;]</code> 这个 Resolver 里返回的是 <code>{ name: &quot;Mark&quot;, friend: &quot;Tony&quot; }</code> 那最终查询结果会是什么呢？</p>

<h2 id="总结">总结</h2>

<p>Schema：用于声明 GraphQL 语句能够查询什么样的数据。</p>

<p>GraphQL 语句：用于描述需要查询哪些数据。</p>

<p>Resolver：用于返回需要的数据。</p>


  <footer>
  

<section class="comments">
  <div id="disqus_thread"></div>
  <script>
  var disqus_config = function () {
  
    this.page.url = "https:\/\/nekocode.cn" + location.pathname;
  
  };
  (function() {
    var inIFrame = function() {
      var iframe = true;
      try { iframe = window.self !== window.top; } catch (e) {}
      return iframe;
    };
    if (inIFrame()) return;
    var disqus_js = '//nekocode.disqus.com/embed.js';
    var d = document, s = d.createElement('script');
    s.src = disqus_js; s.async = true;
    s.setAttribute('data-timestamp', +new Date());
    var b = false, l = function() {
      if (b) return;
      (d.head || d.body).appendChild(s); b = true;
    }
    
    if (location.hash.match(/^#comment/)) return(l());
    var t = d.getElementById('disqus_thread');
    var c = function() {
      if (b) return;
      var rect = t.getBoundingClientRect();
      if (rect.top < window.innerHeight && rect.bottom >= 0) l();
    };
    window.addEventListener('load', c);
    d.addEventListener('scroll', c);
  })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>


  



<script src="//cdn.bootcss.com/highlight.js//highlight.min.js"></script>



<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



  
  <hr>
  <div class="copyright">&copy; Mark Yueng 2017 | <a href="https://github.com/nekocode/nekocode.cn/">Source code</a></div>
  
  </footer>
  </article>
  
  </body>
</html>

