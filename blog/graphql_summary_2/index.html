<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>GraphQL 纪要（二） - 杨凡</title>
    <meta property="og:title" content="GraphQL 纪要（二） - 杨凡">
    

    
      
    

    

    
    




    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  
  <body class="blog">
    <header class="masthead">
      <h1><a href="/">杨凡</a></h1>

<p class="tagline">Personal blog of Mark Yueng.</p>

      <nav class="menu">
        <input id="menu-check" type="checkbox" />
        <label id="menu-label" for="menu-check" class="unselectable">
          <span class="icon close-icon">✕</span>
          <span class="icon open-icon">☰</span>
          <span class="text">Menu</span>
        </label>
        <ul>
        
        
        <li><a href="/">Home</a></li>
        
        <li><a href="/project-gallery">Project Gallery</a></li>
        
        <li><a href="/resume.pdf">Resume</a></li>
        
        
        </ul>
      </nav>
    </header>

    <article class="main">
      <header class="title">
      
<h1>GraphQL 纪要（二）</h1>

<h3>
  2018-10-20</h3>
<hr>


      </header>





<h2 id="resolver-设计">Resolver 设计</h2>

<p>我们可能会在 Resolver 里做一些耗时的操作（例如操作 Database）。为了保证我们尽可能快地响应用户的查询，我们必须保证只对那些用户需要的字段进行查询。</p>

<p>首先举个反例，我们定义了以下的 Schema：</p>

<pre><code>type Query {
  getPost: Post
}

type Post {
  title: String
  authorName: String
}
</code></pre>

<p>对应的 Resolver Map：</p>

<pre><code>export const resolverMap: IResolvers = {
  Query: {
    getPost: {
      resolve: () =&gt; {
        const post = queryPostDbTable();
        const author = queryUserDbTable(post.authorId);
        return {
          title: post.title,
          authorName: author.name;,
        };
      },
    },
  },
};
</code></pre>

<p>可以看到，在 getPost 字段的 Resolver 里会查询 Post 和 User 表。糟糕的是，即便用户并没有查询 authorName 字段，在获取 getPost 字段的时候也会查询 User 表。这造成了冗余的数据库操作。</p>

<p>为了解决这个问题，我们应当把 authorName 字段的获取放到另一个 Resolver 里。例如：</p>

<pre><code>export const resolverMap: IResolvers = {
  Query: {
    getPost: {
      resolve: () =&gt; {
        return queryPostDbTable();
      },
    },
  },
  Post: {
    authorName: {
      resolve: (post) =&gt; {
        return queryUserDbTable(post.authorId).name;
      },
    },
  },
};
</code></pre>

<p>这样可以只在用户查询到 authorName 字段时才去查询 User 表。</p>

<p>现在再假设一下，如果 Post 里还要返回用户头像路径的话，例如 Schema 为：</p>

<pre><code>type Post {
  title: String
  authorName: String
  authorAvatar: String
}
</code></pre>

<p>这种情况，Resolver 又不好设计了。</p>

<p>实际上，查询一次 User 表就可以同时获得 authorName 和 authorAvatar 字段了。但如果按照上面的设计，把这两个字段放在单独的 Resolver 里的话，那么如果用户同时查询这两个字段，会查询两次 User 表。</p>

<p>所以说这种扁平的 Schema 设计其实是不好，更好的设计应该是：</p>

<pre><code>type Post {
  title: String
  author: User
}

type User {
  name: String
  avatar: String
}
</code></pre>

<p>对应 Resolver Map：</p>

<pre><code>export const resolverMap: IResolvers = {
  Query: {
    getPost: {
      resolve: () =&gt; {
        return queryPostDbTable();
      },
    },
  },
  Post: {
    author: {
      resolve: (post) =&gt; {
        return queryUserDbTable(post.authorId);
      },
    },
  },
};
</code></pre>

<h2 id="graphql-orver-prisma">GraphQL Orver Prisma</h2>

<p>Prisma 是基于 GraphQL 的最流行的 ORM 框架之一。我们可以使用 Prisma 提供的类似 GraphQL Schema 的语法来定义我们的所有 Model，然后 Prisma 会帮我们在数据库中建立对应的表和列，并生成一个包含增删查改这些 Model 功能的 GraphQL 服务。</p>

<p>简单来说，通过 Prisma，我们可以使用 GraphQL 语句来操作数据库。</p>

<p>而使用 Prisma 的好处是，我们可以 Prisma 上再搭建一层 GraphQL 服务来处理更高层的业务逻辑，这样很多操作 Model 的 GraphQL 请求可以直接转发给 Prisma 处理。在定义 Schema 时，很多 Type 甚至可以复用 Prisma 生成的。</p>

<p>有兴趣的可以看下我写的 <a href="https://github.com/nekocode/typescript-graphql-over-prisma">DEMO</a>。它能帮助你快速搭建一个后端服务。</p>

<h2 id="其它">其它</h2>

<p>实际上，无论在功能还是性能上，GraphQL 都是特别薄的一层，它所做的仅仅是把 GraphQL 语句解析成 AST，然后执行对应的 Resolver 而已。你甚至可以把它作为 Api Gateway，用它来包裹其它微服务的接口。</p>

<p>而对比过往 Rest 的接口设计，GraphQL 作为一门「语言」描述明显能力更强。你可以在一条 GraphQL 语句里按需查询你所有需要的数据，仅需要一次网络请求，而如果你的 Resolver 设计的足够好的话，不会像 Rest 接口那样可能造成冗余的查询。</p>


  <footer>
  

<section class="comments">
  <div id="disqus_thread"></div>
  <script>
  var disqus_config = function () {
  
    this.page.url = "https:\/\/nekocode.cn" + location.pathname;
  
  };
  (function() {
    var inIFrame = function() {
      var iframe = true;
      try { iframe = window.self !== window.top; } catch (e) {}
      return iframe;
    };
    if (inIFrame()) return;
    var disqus_js = '//nekocode.disqus.com/embed.js';
    var d = document, s = d.createElement('script');
    s.src = disqus_js; s.async = true;
    s.setAttribute('data-timestamp', +new Date());
    var b = false, l = function() {
      if (b) return;
      (d.head || d.body).appendChild(s); b = true;
    }
    
    if (location.hash.match(/^#comment/)) return(l());
    var t = d.getElementById('disqus_thread');
    var c = function() {
      if (b) return;
      var rect = t.getBoundingClientRect();
      if (rect.top < window.innerHeight && rect.bottom >= 0) l();
    };
    window.addEventListener('load', c);
    d.addEventListener('scroll', c);
  })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>


  



<script src="//cdn.bootcss.com/highlight.js//highlight.min.js"></script>



<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



  
  <hr>
  <div class="copyright">&copy; Mark Yueng 2017 | <a href="https://github.com/nekocode/nekocode.cn/">Source code</a></div>
  
  </footer>
  </article>
  
  </body>
</html>

